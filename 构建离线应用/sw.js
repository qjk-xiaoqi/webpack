/*
// 1、Service Workers兼容性，与注册Service Workers
         // 判断浏览器是否支持Service Workers,支持就注册一个描述Service Workers的脚本文件

// if (navigator.serviceWorker) {
//     window.addEventListener('DOMContentLoad', function() {
//         // 调用serviceWorker.register注册，参数/sw.js为脚本文件所在的URL路径
//         navigator.serviceWorker.register('/sw.js')
//     })
// }

// 2、Service Workers的脚本文件内容：
    // 当前缓存版本的唯一标识符，用当前时间代替
    var cacheKey = new Date().toISOString();
    // 当前缓存的白名单，在新脚本的install事件里将使用报名单里的key
    var cacheWhitelist = [cacheKey];
    // 需要被缓存的文件的URL列表
    var cacheFileList = [
        '/index.html',
        '/app.js',
        'app.css'
    ];

    // 监听install事件
    self.addEventListener('install', function(event) {
        // 等待所有资源缓存完成时，才可以进行下一步
        event.waitUntil(
            caches.open(cacheKey).then(function(cache) {
                // 要缓存的文件的URL列表
                return  cache.addAll(cacheFileList);
            })
        )
    })
    // 拦截网络请求
    self.addEventListener('fetch', function(event) {
        event.respondWith(
            // 去缓存中查询对应的请求
            caches.match(event.request).then(function(response) (
                // 如果命中本地缓存，就直接返回本地的资源
                if(response){
                    return response;
                }
                // 否则就用fetch下载资源
                return fetch(event.request);
            ))
        )
    })
    // 新的Service Workers线程取得控制权后，将会触发activate事件
    self.addEventListener('activate', function(event) {
        event.waitUntil(
            caches.keys().then(function (cacheNames) {
                return Promise.all(
                    cacheNames.map(function (cacheName) {
                        // 将不在白名单中的缓存全部清理掉
                        if(cacheWhitelist.indexOf(cacheName) === -1){
                            // 删除缓存
                            return caches.delete(cacheName);
                        }
                    })  

                     
                );
            })
        );
    });

*/

var serviceWorkerOption = {
    "assets": [
      "/app.js",
      "/app.css",
      "/index.html"
    ]
  };
          
          /******/ (function(modules) { // webpackBootstrap
  /******/ 	// The module cache
  /******/ 	var installedModules = {};
  /******/
  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {
  /******/
  /******/ 		// Check if module is in cache
  /******/ 		if(installedModules[moduleId]) {
  /******/ 			return installedModules[moduleId].exports;
  /******/ 		}
  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = installedModules[moduleId] = {
  /******/ 			i: moduleId,
  /******/ 			l: false,
  /******/ 			exports: {}
  /******/ 		};
  /******/
  /******/ 		// Execute the module function
  /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  /******/
  /******/ 		// Flag the module as loaded
  /******/ 		module.l = true;
  /******/
  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}
  /******/
  /******/
  /******/ 	// expose the modules object (__webpack_modules__)
  /******/ 	__webpack_require__.m = modules;
  /******/
  /******/ 	// expose the module cache
  /******/ 	__webpack_require__.c = installedModules;
  /******/
  /******/ 	// define getter function for harmony exports
  /******/ 	__webpack_require__.d = function(exports, name, getter) {
  /******/ 		if(!__webpack_require__.o(exports, name)) {
  /******/ 			Object.defineProperty(exports, name, {
  /******/ 				configurable: false,
  /******/ 				enumerable: true,
  /******/ 				get: getter
  /******/ 			});
  /******/ 		}
  /******/ 	};
  /******/
  /******/ 	// getDefaultExport function for compatibility with non-harmony modules
  /******/ 	__webpack_require__.n = function(module) {
  /******/ 		var getter = module && module.__esModule ?
  /******/ 			function getDefault() { return module['default']; } :
  /******/ 			function getModuleExports() { return module; };
  /******/ 		__webpack_require__.d(getter, 'a', getter);
  /******/ 		return getter;
  /******/ 	};
  /******/
  /******/ 	// Object.prototype.hasOwnProperty.call
  /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  /******/
  /******/ 	// __webpack_public_path__
  /******/ 	__webpack_require__.p = "";
  /******/
  /******/ 	// Load entry module and return exports
  /******/ 	return __webpack_require__(__webpack_require__.s = 0);
  /******/ })
  /************************************************************************/
  /******/ ([
  /* 0 */
  /***/ (function(module, exports, __webpack_require__) {
  
  /* WEBPACK VAR INJECTION */(function(global) {// 当前缓存版本的唯一标识符，用当前时间代替
  var cacheKey = new Date().toISOString();
  
  // 当前缓存白名单，在新脚本的 install 事件里将使用白名单里的 key
  var cacheWhitelist = [cacheKey];
  
  // 需要被缓存的文件的 URL 列表
  var cacheFileList = global.serviceWorkerOption.assets;
  
  // 监听 install 事件
  self.addEventListener('install', function (event) {
    // 等待所有资源缓存完成时，才可以进行下一步
    event.waitUntil(
      caches.open(cacheKey).then(function (cache) {
        // 要缓存的文件 URL 列表
        return cache.addAll(cacheFileList);
      })
    );
  });
  
  // 拦截网络请求
  self.addEventListener('fetch', function (event) {
    event.respondWith(
      // 去缓存中查询对应的请求
      caches.match(event.request).then(function (response) {
          // 如果命中本地缓存，就直接返回本地的资源
          if (response) {
            return response;
          }
          // 否则就去用 fetch 下载资源
          return fetch(event.request);
        }
      )
    );
  });
  
  // 新 Service Workers 线程取得控制权后，将会触发其 activate 事件
  self.addEventListener('activate', function (event) {
    event.waitUntil(
      caches.keys().then(function (cacheNames) {
        return Promise.all(
          cacheNames.map(function (cacheName) {
            // 不在白名单的缓存全部清理掉
            if (cacheWhitelist.indexOf(cacheName) === -1) {
              // 删除缓存
              return caches.delete(cacheName);
            }
          })
        );
      })
    );
  });
  
  /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))
  
  /***/ }),
  /* 1 */
  /***/ (function(module, exports) {
  
  var g;
  
  // This works in non-strict mode
  g = (function() {
      return this;
  })();
  
  try {
      // This works if eval is allowed (see CSP)
      g = g || Function("return this")() || (1,eval)("this");
  } catch(e) {
      // This works if the window reference is available
      if(typeof window === "object")
          g = window;
  }
  
  // g can still be undefined, but nothing to do about it...
  // We return undefined, instead of nothing here, so it's
  // easier to handle this case. if(!global) { ...}
  
  module.exports = g;
  
  
  /***/ })
  /******/ ]);
